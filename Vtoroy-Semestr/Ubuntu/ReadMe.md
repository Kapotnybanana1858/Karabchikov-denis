# Защита Работа с файлами:
<br>1. Какая особенность при удалении директорий?
Появляеться особый ключ -r который удаляет файлы и саму директорию.
<br>2. В чем разница жестких и мягких ссылок?
Мягкая сыллка - ссылаются  на имя файла, а жесткие сыллки ссылаются на оригинальный файл(Вместе со всем содержимым)
<br>3-4. Что такое инод и какой командой вызывается?
Уникальные номер файла. Команда для вызова - -inum
<br>5. Что значит знак $ в скрипте?
Означает подсказку для пользователя в посике директории, файла и тд. по этой подсказке пользователь записывает в терминал треубуемые данные.
# Защита Скрипт пользователя:
1. В каком файле найти информацию о пользователях в системе: 
2. etc/passwd
3. Как открыть файл с переменными окружения:
С помощью команды getit где указывается путь на файл.
4. Как удалить пользователя: 
с помощью userdel.
4-5. Два способа создания меню с выбором: 
Первый способ это вызов функции, Второй способ это выбор команды через select.
# Защита Работа с БД:
1. За счет чего мы получаем подключение к серверу (и в коде, и в командной строке, и в настройках машины)
 В коде с помощью :
def get_connection():
    return ps.connect(dbname=DB_NAME, user=DB_USER,
                    password=DB_PASSWORD, host=DB_HOST, options=OPTS)
c помощью командной строки : ./pg_start
с помощью машины : заходим в настройки машины -> сеть -> дополнительно -> подброс портов -> меняем порты хоста и гостя на 5432
2. Что такое mutex
 Для блокировки общих данных от одновременного доступа 
3 Разница синхронной и асинхронной записи
В синхронный он записывает каждую запись по порядку, а в асинхроном случайным образом
4 Как мы делим информацию на 10 потоков?
с помощью : def next(self):
        pos = None
        with self.mutex:
            if self.pos < self.count:
                self.pos += 1
                pos = self.pos
                # чтобы пользователь видел, на каком шаге программа, будем выводить в консоль на какой мы позицию с шагом в 10.000
                if pos % 10000 == 0: 
                    print(pos)

        return pos
5 Как мы получаем данные из таблицы?
с помощью : SELECT count(id) FROM ticket_flights_tmp


<br>LOG AND PASS :<br>
<br>KAPOTNYA<br>
<br>QWERTS1858<br>
![image](https://user-images.githubusercontent.com/90246832/149878385-df6978f5-60fa-4d61-9ad7-0aa95c090f68.png)

![image](https://user-images.githubusercontent.com/90246832/149882225-356728ee-5b3b-42ed-b34e-9ca7b7ee916a.png)


https://docs.google.com/document/d/1z27O5xLblWKjIxcXRZnbd1smm-oYa8bt/edit

<li>ls - позволяет посмотреть, какие пап вам доступны
<li>cd 'Рабочий стол' - позволяет перейти в папку, где лежит Ваш код
<li>gcc Hello.c -o test - компилирует вашу программу в файл с именем test (имя можно менять, если файлу не задать название, по стандарту будет выставлено название "а.out")
<li>/test - запуск кода.
  
![скрипт 1](https://user-images.githubusercontent.com/90246832/151492400-1af19c47-5a3b-40f2-8d03-2fc1eb2b00f4.PNG)
  
![скрипт 2](https://user-images.githubusercontent.com/90246832/151492405-90c08211-d24e-4119-96a6-e8a38e83483d.PNG)
  
![скрипт3](https://user-images.githubusercontent.com/90246832/151494427-d672248d-9310-4a22-8b47-39a822c421f1.png)
  
 Процесс - набор ресурсов задачи во время ее выполнения
<li>память
<li>файловые дескрипторы
<li>контекст выполнения
<li>обработчики сигналов
<li>как минимум, один поток
<br>
Потоки имеют:
<li>общую виртуальную память
<li>каждый - свой виртуальный процессор

<br>Структура памяти процесса:
<br>Stack- адреса возврата из подпрограмм (аргументы функций), локальные переменные 
<br>mmap- разделяемая библиотека
<br>Неиспользованная память
<br>heap (Куча)
<br>BSS- неициализированные глобальные и статистические переменные
<br>data- инициализированные глобальные и статистические переменные
<br>text- код программы

<br>Трансляция адресов - первод виртуальной памяти в физическую

<br>Виртуальная файловая система:
  PID - Уникальный номер процесса.
<li>не имеет существующих файлов, существует только в оперативной памяти
<li>содержит информацию о системы 
<li>в файлы можно писать значения, изменяя этим параметры системы
<li>/proc/PID/maps - карта памяти процесса
<li>/proc/PID/fd - открытые файловые дескрипторы
<li>/proc/PID/environ - переменные окружения
<li>/proc/PID/exe - симлинк на исполняемый файл
<li>/proc/PID/cwd - симлинк на директорию, откуда запущен процесс
<li>/proc/PID/status - состояние процесса в человекочитаемом виде

<br>#include <unistd.h>
<br>#include <malloc.h>
<br>#include <stdio.h>
<br>#include <sys/mman.h>

<br>int data=10; 
<br>int main(int argc, char *argv[])
<br>{
<br>int stack; 
<br>void *heap;
<br>heap=malloc(1);
<br>printf("PID=%i\n", getpid());
<br>printf("Text=%p\n", main);
<br>printf("Data=%p\n", &data);
<br>printf("libc.so=%p\n", printf);
<br>printf("Stack=%p\n", &stack);

<br>sleep(100);

<br>return 0;
<br>}  
  
  ![Снимок экрана от 2022-01-31 11-32-00](https://user-images.githubusercontent.com/90246832/151761798-e63529f1-2c0d-43fd-b7a0-63efc83bf650.png)
  
  
<br>#include <unistd.h>
<br>#include <malloc.h>
<br>#include <stdio.h>
<br>#include <sys/mman.h>

<br>int data=10;
<br>int func(int a)
<br>{
<br>printf("%i\n", a);
<br>return func(a+1);
<br>}
<br>int main(int argc, char *argv[])
<br>{
<br>printf("PID=%i\n", getpid());
<br>func(1);
<br>return 0;
<br>}
  
  ![Снимок экрана от 2022-01-31 11-47-43](https://user-images.githubusercontent.com/90246832/151763834-f0665bfd-c653-4c6b-ac40-a9573bc71566.png)
  
  <br>Далее создадим класс Cursor, при инициализации которого вызывается блокировка потока, обнуляется позиция и передается количество строк в базе. Для потоко-безопасного <br>получения следующего индекса напишем функцию next, которая смещает счетчик позиции на 1, пока мы не пройдем по всем строкам базы. Чтобы пользователь видел, на каком шаге <br>программа, будем выводить в консоль на какой мы позицию с шагом в 10.000. Пример вывода на экран на скриншоте 3
<br>Скриншот 3. вывод на экран прохождения записей.


<br>В функции thread_worker опишем работу с потоками. Подключаемся для каждого потока к нашей БД, определяем нашу позицию с помощью класса Cursor и создадим файл для записи с <br>именем res_Номер потока_False, где False означает, что вначале рассматривается использование буфера. Пока мы проходим по всем строкам с помощью запроса SELECT * FROM <br>ticket_flights_tmp WHERE id={pos}. Метод .fetchone() возвращает первую запись, полученную при запросе и мы записываем ее в файл в виде

<br>0005432159776 30625 Business 42100.00 1 0
<br>Номер билета Номер рейса Класс Цена Номер строки Номер потока.
<br>Файл False приведен на скриншоте 4.
<br>image
<br>

<br>Когда мы не используем буфер, строки сначала записываются во все 10 файлов, потом 11 снова записывается в первый файл. Функция flush очищает выходной буфер и перемещает <br>буферизованные данные на диск. Мы создали условие if flush: (чтобы использовать ее только во 2м случае, когда передадим параметр True). В этом случае сначала все строки <br>записываются в 0й файл, потом переходят к 1му и так далее. Файл True приведен на скриншоте 5. image

<br>После этого с помощью метода .close() закрываем файлы и соединение


<br>Чтобы определить сколько строк в нашей таблице, напишем функцию get_rows_count, которая использует запрос SELECT count(id) FROM ticket_flights_tmp


<br>Далее нам нужна функция calculate_time_exec для вычисления времени выполнения всех 10 потоков. Нам понадобится модуль time и метод .time(), чтобы получить время, выраженное <br>в секундах с начала эпохи в начале работы программы и в конце, разница нам даст время обработки потоков. Указываем, что у нас 10 потоков мы пишем цикл, в котором с помощью <br>метода .append() создаем потоки с помощью целевой функции thread_worker, описанной выше. И выводим в консоль результат работы программы (скриншоты 6 и 7).

<br>Первое прохождение 183.1251289844513 s Второе прохождение 189.37589025497437 s Время увеличилось на 6,25с, или на 3,4%, так как мы уведомляем систему что надо записать на <br>диск, и не использовать буфер. В данной работе при создании потоков, для блокировки общих данных от одновременного доступа использовались такие объекты синхронизации, как <br>мютексы( self.mutex = threading.Lock() ),

<br>Multi-Protocol MasterOPC Server – это семейство OPC-серверов DA/HDA/UA для обмена с устройствами по различным протоколам.
<br>Протокол (protocol) - стандарт, определяющий поведение функциональных блоков при передаче данных.
<br>Брокер сообщений - Архитектурный паттерн в распределённых системах; приложение, которое преобразует сообщение по одному протоколу от приложения-источника в сообщение протокола приложения-приёмника, тем самым выступая между ними посредником.
